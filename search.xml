<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode_1-两数之和_javascript</title>
      <link href="/2020/07/15/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-javascript/"/>
      <url>/2020/07/15/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-javascript/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>1.两数之和</p><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>javascript 解法</li></ul><ul><li>一开始看到这个下意识就想先排序，然后用两个变量记录下标，假设两个变量为<code>x = 0</code>，<code>y = arr.length - 1</code>,那么<code>arr[x]</code>,<code>arr[y]</code>就分别代表最小和最大的值了，这时候再进入循环判断，如果小于target，则 <code>x += 1</code>,若大于target，则<code>y -= 1</code>,直到相等之后就跳出循环。</li></ul><ul><li>复杂度就是sort的nlogn，最后代码的运行时间在80ms，内存消耗36.8MB</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> copy = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> k=<span class="number">0</span>; k &lt;= nums.length - <span class="number">1</span>; k++) &#123;</span><br><span class="line">    <span class="comment">// 这边copy是要记录原来数字的下标，排序之后就会打乱</span></span><br><span class="line">    <span class="comment">// 又因为js中数组是引用类型，如果直接复制的话是浅拷贝是不行的，当然这样子也是浅拷贝，不过都是数字就无所谓了</span></span><br><span class="line">      copy.push(nums[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] + nums[j] === target) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] + nums[j] &lt; target) &#123;</span><br><span class="line">          i += <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          j -= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">-1</span>, n = <span class="number">-1</span>, flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k=<span class="number">0</span>;k&lt;nums.length;k++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (flag == <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] === copy[k] &amp;&amp; m === <span class="number">-1</span>) &#123;</span><br><span class="line">          m = k;</span><br><span class="line">          flag++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[j] === copy[k] &amp;&amp; n === <span class="number">-1</span>) &#123;</span><br><span class="line">          n = k;</span><br><span class="line">          flag++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [m, n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>JavaScript内置的sort方法对数字的排序是无效的，所以需要另外传进去一个函数来进行判断</li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue+elementUI实现简单的问卷</title>
      <link href="/2020/06/30/vue-elementUI%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E9%97%AE%E5%8D%B7/"/>
      <url>/2020/06/30/vue-elementUI%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E9%97%AE%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>最近参加比赛的一个题目需要实现问卷功能，于是我就开始闷头搞了hhh，功能比较简陋，只实现了问卷发布填写结果预览这三个功能</p><p>先看一下几个主要的界面：</p><ul><li>创建问卷<br><img src="//yoursite.com/2020/06/30/vue-elementUI%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E9%97%AE%E5%8D%B7/qs_cr.png" alt="创建问卷"></li></ul><hr><h2 id="问卷功能"><a href="#问卷功能" class="headerlink" title="问卷功能"></a>问卷功能</h2><h3 id="创建问卷"><a href="#创建问卷" class="headerlink" title="创建问卷"></a>创建问卷</h3><h3 id="填写问卷"><a href="#填写问卷" class="headerlink" title="填写问卷"></a>填写问卷</h3><h3 id="问卷结果查看"><a href="#问卷结果查看" class="headerlink" title="问卷结果查看"></a>问卷结果查看</h3>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级编程chapter5</title>
      <link href="/2020/06/23/js%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8Bchapter5/"/>
      <url>/2020/06/23/js%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8Bchapter5/</url>
      
        <content type="html"><![CDATA[<h1 id="chapter-5"><a href="#chapter-5" class="headerlink" title="chapter 5"></a>chapter 5</h1><h2 id="5-5-Function类型"><a href="#5-5-Function类型" class="headerlink" title="5.5 Function类型"></a>5.5 Function类型</h2><p><em>更新5.6</em></p><p>函数实际上是<code>对象</code>,每个函数都是Function类型的实例，因此与其他引用类型一样具有<code>属性和方法</code></p><p>因此函数名实际上就是函数对象的<code>指针</code>，不会与某个函数绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因此函数可以这么定义</span></span><br><span class="line"><span class="comment">// 可以用来理解 函数是对象，函数名是指针</span></span><br><span class="line"><span class="comment">// 但是不推荐这么定义函数</span></span><br><span class="line"><span class="keyword">const</span> myFun = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'num1'</span>, <span class="string">'num2'</span>, <span class="string">'return num1 + num2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个函数可以有多个名字</span></span><br><span class="line">funtion age() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'my age is 19'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myAge = age;</span><br><span class="line">myAge();  <span class="comment">// 19</span></span><br><span class="line">age();    <span class="comment">// 19</span></span><br></pre></td></tr></table></figure><h3 id="5-5-1-没有重载（深入理解）"><a href="#5-5-1-没有重载（深入理解）" class="headerlink" title="5.5.1 没有重载（深入理解）"></a>5.5.1 没有重载（深入理解）</h3><ol><li>把函数名现象做指针，可以帮助理解为何没有重载</li><li>重复声明两个同名函数只会覆盖前一个的引用</li></ol><h3 id="5-5-2-函数声明与函数表达式"><a href="#5-5-2-函数声明与函数表达式" class="headerlink" title="5.5.2 函数声明与函数表达式"></a>5.5.2 函数声明与函数表达式</h3><p>解析器在向执行环境中加载数据时，会率先读取函数声明，并使其在执行任何函数代码前可用。即<code>函数声明提升</code></p><h3 id="5-5-3-作为值的函数"><a href="#5-5-3-作为值的函数" class="headerlink" title="5.5.3 作为值的函数"></a>5.5.3 作为值的函数</h3><p>因为函数名本就是一个变量，所以可以将函数作为另一个函数的结合返回<br><code>要访问函数的指针而不执行函数的话</code>，必须去掉大括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// sort示例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> value1 = object1[propertyName];</span><br><span class="line">        <span class="keyword">const</span> value2 = object2[propertyName];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'azoux1'</span>,</span><br><span class="line">        age； <span class="number">19</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'azoux2'</span>,</span><br><span class="line">        age； <span class="number">190</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br><span class="line">data.sort(compare, <span class="string">'name'</span>); <span class="comment">// 按name排序</span></span><br><span class="line">data.sort(compare, <span class="string">'age'</span>);  <span class="comment">// 按age排序</span></span><br></pre></td></tr></table></figure><h3 id="5-5-4函数内部属性"><a href="#5-5-4函数内部属性" class="headerlink" title="5.5.4函数内部属性"></a>5.5.4函数内部属性</h3><ul><li>两个特殊的对象<ul><li>this</li><li>arguments – 保存函数参数<ul><li><code>callee属性</code> – 指向拥有这个arguments对象的函数</li></ul></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用callee实现阶乘递归 降低耦合</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>【松耦合】的方法，一般是底层函数，功能尽量单一，尽量避免修改底层函数。功能相近的函数，可以设计2个以上，不要为了减少代码量，把一个函数的功能设计的太多</em></p><h3 id="5-5-5-函数属性的方法"><a href="#5-5-5-函数属性的方法" class="headerlink" title="5.5.5 函数属性的方法"></a>5.5.5 函数属性的方法</h3><pre><code>每个函数包含两个属性：length和property。其中length是希望接受的参数个数property是保存所有的实例方法，诸如toString()等...在es5中property的属性是不可以枚举的（for-in无效）</code></pre><p><em>call()和apply()真正的用武之地不在于传递参数，而是扩充函数赖以运行的作用域</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 举个例子</span></span><br><span class="line"><span class="built_in">window</span>.color = <span class="string">'red'</span>;</span><br><span class="line"><span class="built_in">window</span>.age = <span class="number">10</span>;</span><br><span class="line">o = &#123;</span><br><span class="line">    color: <span class="string">'blue'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showColor(); <span class="comment">// red</span></span><br><span class="line"><span class="comment">// red 是因为当前调用showColor的是window对象</span></span><br><span class="line"></span><br><span class="line">showColor.call(o) <span class="comment">//blue</span></span><br><span class="line"><span class="comment">// call() 扩充了作用域 它会在o对象中寻找color属性，如果没有就是undefined</span></span><br></pre></td></tr></table></figure><p><em>apply与call相似，只是传入其余参数的方式不同</em><br><em>扩充作用域的最大好处就是对象不需要和方法有任何*</em>耦合关系***</p><p><em>bind()</em></p><pre><code>bind顾名思义就是绑定，在绑定完传入的对象之后返回一个新的函数</code></pre><hr><h2 id="5-6-基本包装类型"><a href="#5-6-基本包装类型" class="headerlink" title="5.6 基本包装类型"></a>5.6 基本包装类型</h2><p>ECMAScript提供了三个特殊的引用类型： <code>Bolean, Number, String</code><br>每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象<br><em>这就是为何我们可以对字符串或者数字使用一些方法</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">'hello woeld'</span>;</span><br><span class="line"><span class="keyword">const</span> str2 = str.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>当处理上面代码访问str1时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值，而在读取模式访问字符串的时候，后台都会自动完成如下操作:</p><ol><li>创建String类型的一个实例</li><li>在实例上调用制定的方法</li><li>销毁这个实例</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面三步用代码描述的话,就是这样</span></span><br><span class="line"><span class="keyword">const</span> str1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'some text'</span>);</span><br><span class="line"><span class="keyword">const</span> str2 = str1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>引用类型与基本包装类型的主要区别就是对象的生存期。<strong>使用new创建的引用类型的实例，在执行流离开当前作用域之前一直都保存在内存中。而自动创建的基本包装类型对象，则只存在于一行代码的执行瞬间，然后立即被销毁。</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//可以看一下这个例子</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'some text'</span>;</span><br><span class="line">s1.color = <span class="string">'red'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s1.color); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><em>这里s1.color是undefined的原因是，在执行第三行代码之前，第二行创建的string对象已经被销毁了，第三行重新创建String对象，但是没有color属性，所以是undefined</em></p><p> <strong>tips:</strong> 要注意的是，使用new调用的基本包装类型的构造函数，与直接调用同名转型函数是不一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> val = <span class="string">'22;</span></span><br><span class="line"><span class="string">const number = Number(val); // 转型函数</span></span><br><span class="line"><span class="string">console.log(typeof val); // number</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const obj = new Number(val); // 构造函数</span></span><br><span class="line"><span class="string">console.log(typeof obj); // object</span></span><br></pre></td></tr></table></figure><p><em>不建议直接创建基本包装类型的对象</em></p><hr><h3 id="5-6-1-Boolean"><a href="#5-6-1-Boolean" class="headerlink" title="5.6.1 Boolean"></a>5.6.1 Boolean</h3><p>建议永远不要使用Boolean对象</p><hr><h3 id="5-6-2-Number-类型"><a href="#5-6-2-Number-类型" class="headerlink" title="5.6.2 Number 类型"></a>5.6.2 Number 类型</h3><ol><li>toString()</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// toString()方法接受一个参数用于输出几进制的字符串形式</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">10</span>)); <span class="comment">// ’10‘</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>)); <span class="comment">// '1010'</span></span><br><span class="line"><span class="built_in">console</span>.log(num.roString(<span class="number">16</span>)); <span class="comment">// 'a'</span></span><br></pre></td></tr></table></figure><ol start="2"><li>toFixed()<br> <code>接受一个参数，返回指定位数的小数位字符串</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">10</span>;</span><br><span class="line">num.toFixed(<span class="number">2</span>); <span class="comment">// '10.00'</span></span><br></pre></td></tr></table></figure><ol start="3"><li>toExponential()<br> <code>返回指数形式字符串，同样接受一位小数为用于指定输出结果的小数位数</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">10</span>;</span><br><span class="line">num.toExponential(<span class="number">1</span>); <span class="comment">// '1.0e+1'</span></span><br></pre></td></tr></table></figure><ol start="4"><li>toPrecision()<br> 个人感觉意义不大，接受一个参数，返回指定位数的字符串格式</li></ol><hr><h3 id="5-6-3-String-类型"><a href="#5-6-3-String-类型" class="headerlink" title="5.6.3 String 类型"></a>5.6.3 String 类型</h3><p>每个String类型的实例都有length属性，返回字符串的字符数量<br><code>值得注意的是，即使字符串中包含双字节字符（不是占一个字节的ASCII字符），每个字符仍然算是一个字符</code></p><ol><li>字符方法<br> <code>两个用于访问字符串中特定字符的方法是：charAt()和charCodeAt() 两个方法都接受一个参数,基于0的字符位置</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'hello world'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// charAt</span></span><br><span class="line">str.charAt(<span class="number">1</span>); <span class="comment">// 'e'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// charCodeAt</span></span><br><span class="line">str.charCodeAt(<span class="number">1</span>); <span class="comment">// '101'  (101是e的字符编码)</span></span><br></pre></td></tr></table></figure><p><code>也可以通过下标访问：str[0]</code></p><ol start="2"><li>字符串操作方法</li></ol><ul><li>concat()<br>  <code>用于将一或多个字符串拼接起来，可以接受任意多个参数</code></li><li>slice()<br>  <code>接受一或两个参数用于确定分割字符串的开始和结尾</code></li><li>substr()<br>  <code>接受一或两个参数用于确定分割字符串的开始和返回的个数</code></li><li>substring()<br>  <code>接受一或两个参数用于确定分割字符串的开始和结尾</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concat </span></span><br><span class="line"><span class="keyword">const</span> str1 = <span class="string">'hello '</span>;</span><br><span class="line"><span class="keyword">const</span> result = str1.concat(<span class="string">'hhh'</span>,<span class="string">' world'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 'hello hhh world' </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice substr sbustring</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">'hello world'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str2.slice(<span class="number">2</span>, <span class="number">4</span>)); <span class="comment">// 'll'</span></span><br><span class="line"><span class="built_in">console</span>.log(str2.substr(<span class="number">2</span>, <span class="number">4</span>)); <span class="comment">// 'llo '</span></span><br><span class="line"><span class="built_in">console</span>.log(str2.substring(<span class="number">2</span>, <span class="number">4</span>)); <span class="comment">// 'll'</span></span><br></pre></td></tr></table></figure><p><code>在这里多提一句，连接字符串还是建议使用es6的$来拼接</code></p><ol start="3"><li>字符串位置方法</li></ol><ul><li><p>indexOf(‘son str’, begin)<br><code>返回子字符串位置, 正序搜索，第二个参数指定开始位置</code></p></li><li><p>lastIndexOf(‘son str’, begin)<br><code>返回子字符串位置， 倒序搜索，第二个参数指定开始位置</code></p></li></ul><ol start="4"><li>trim() 方法<br><code>删除字符串前后空格</code></li></ol><p><em>还有 trimLeft() 和 trimRight() 方法</em></p><ol start="5"><li>字符串大小写转换方法</li></ol><ul><li><p>toUpperCase()<br><code>转化成大写</code></p></li><li><p>toLowerCase()<br><code>转化成小写</code></p></li></ul><p><em>另外，toLocalUpperCase() 和 toLocalLowerCase() 个人感觉没什么用</em></p><ol start="6"><li>字符串的模式匹配方法</li></ol><ul><li><p>match( patton )<br><code>patton支持正则表达式或RegExp对象，本质与调用RegExp的exec()方法无异</code><br><code>match方法返回一个满足匹配规则的字符数组</code></p></li><li><p>search()<br><code>接受一个参数，可以是字符串或者RegExp</code><br><code>返回第一个匹配项的索引，没有找到则返回-1</code></p></li><li><p>replace()<br>建议查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="noopener">MDN-replace( )</a></p></li></ul><ol start="7"><li>localeCompare()<br><code>比较两个字符串，直接上例子</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">'yellow'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较字符串时是逐个比较过去</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.localeCompare(<span class="string">'black'</span>)); <span class="comment">// 1   </span></span><br><span class="line"><span class="built_in">console</span>.log(str1.localeCompare(<span class="string">'yellow'</span>)); <span class="comment">// 0   </span></span><br><span class="line"><span class="built_in">console</span>.log(str1.localeCompare(<span class="string">'zoo'</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><ol start="8"><li>fromCharCode()<br><code>接收一或多个字符串编码，然后将他们转化成字符串</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>)); <span class="comment">// ‘hello’</span></span><br></pre></td></tr></table></figure><ol start="9"><li>HTML方法<br><code>javascript动态格式化，但如此创建的标签，一般都无法表述语义，尽量不使用</code></li></ol><hr>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>learning how to learn(1)</title>
      <link href="/2020/06/23/learning-how-to-learn-1/"/>
      <url>/2020/06/23/learning-how-to-learn-1/</url>
      
        <content type="html"><![CDATA[<h1 id="week1"><a href="#week1" class="headerlink" title="week1"></a>week1</h1><p><em>这是我学习 <strong>learning how to learn</strong> 的总结笔记</em></p><hr><h2 id="集中与发散思维概论"><a href="#集中与发散思维概论" class="headerlink" title="集中与发散思维概论"></a>集中与发散思维概论</h2><p><em>当我们学习新事物时 *</em>比喻和类比都是有效的方法***</p><p><code>集中思维</code></p><pre><code>当我们解决问题或者理解新的概念的时候当你一心一意的专注于某些东西上 试着去学习或者去理解它们的时候 就是“专注” </code></pre><p><code>发散思维</code></p><pre><code>当我们需要一些新的想法的时候，就要依靠发散思维</code></pre><hr><h2 id="拖延症、记忆与睡眠"><a href="#拖延症、记忆与睡眠" class="headerlink" title="拖延症、记忆与睡眠"></a>拖延症、记忆与睡眠</h2><h3 id="拖延症简介"><a href="#拖延症简介" class="headerlink" title="拖延症简介"></a>拖延症简介</h3><p>拖延症：当我们看到一件我们极不情愿的事情时，就像激活了我们大脑的痛觉开关，大脑就会自然而然地去寻找停止这种负面刺激的方式 而这一方式便是将你的注意力转移到其他事情上 不过 我们也有应对之法 研究人员发现 <strong>当人们真正开始去做他们不喜欢的事情后 这种神经上的不适很快就会消失</strong> 看起来 你拖延的过程大概是这样的 首先 你留意到某件事且得到暗示说 这件事可能会让你产生轻微的不安 你不喜欢这种不适 因此为了消除这种感觉 你会让自己不再去关注这件让你不安的事.你会转而去做一些更让人愉悦的事情 这么做的结果就是你觉得更开心了 但这只是暂时的 。</p><p>有一个小技巧来克服拖延症就是使用<strong>番茄钟</strong>。</p><p>一个番茄钟25分钟，在这25分钟内集中注意力去做一件事情，然后休息五分钟，起来转转，喝喝水，浏览浏览网页，给自己一点<strong>奖励</strong>。</p><hr><h3 id="实践使记忆永存"><a href="#实践使记忆永存" class="headerlink" title="实践使记忆永存"></a>实践使记忆永存</h3><p>纵观不同职业，那些涉及到数学与科学的会更有挑战性一些。这可能与<strong>概念的抽象性</strong>有关。正如我们学习英语，学到单词cow（奶牛），我们可以直接在牧场里看到奶牛，就有了抽象单词的具体化。但是在数学里，加减乘除等等都是抽象的概念，我们没有办法在现实生活中找到一种实物来对比。这意味着<strong>练习在数学与科学中学到的概念非常重要</strong>，它将帮你提高和增强学习过程中神经元的连接。这些概念或许是抽象的，但是你在大脑中创建的神经思维模式是具体存在的，练习和实践可以加强神经元之间的连接。越是抽象的东西就越是要注重练习。</p><p>学习的时候做的事情，应当是一心一意地专注， 拼命学习它，<strong>然后休息一下，或者转移你的注意力</strong>。在这段表面上是放松的时间里，你大脑的发散模式，则有机会在后台工作，帮你完成对概念的理解。从某种意义上说，你的神经通路就可以像砂浆一样有个得到固化的机会。如果你不这么做，而是进行填鸭式学习，你的知识库看起来将更像这样 到处杂乱不堪，基础也不牢靠。</p><hr><h3 id="记忆概论"><a href="#记忆概论" class="headerlink" title="记忆概论"></a>记忆概论</h3><p><code>记忆分为两种，分别为工作记忆和长期记忆</code></p><p>我们可以说短期记忆是一个<strong>低效的精神黑板</strong>,而其他的记忆形式呢。长期记忆就像一个存储仓库 就像我们所知道的仓库一样 它占据了一大片区域 </p><p>不同类别的长期记忆储存在大脑不同的区域，研究显示在你第一次尝试 把一个信息放进长期记忆区域，你需要重复记忆它至少几次，才可以增加当你以后需要它的时候想起来的几率。</p><p>重复的记忆可以将短期记忆提升为长期记忆，但是也绝不是短时间内的不断重复，毕竟一口吃不成一个胖子。你需要给他时间冷却。如果不给突触连接形成和加强的时候 你将无法获得好的记忆结构</p><hr><h3 id="睡眠在学习中的重要性"><a href="#睡眠在学习中的重要性" class="headerlink" title="睡眠在学习中的重要性"></a>睡眠在学习中的重要性</h3><p><code>非睡眠时大脑会产生毒物，而睡眠正是排出这些毒物的时候</code>，因为睡眠时脑细胞会缩小，增加脑内细胞之间的距离，液体会在缝隙中冲走那些<code>毒物</code></p><pre><code>在睡眠不足的情况下参加考试 意味着你的大脑一直处于工作状态 以致少量代谢毒素残留在大脑之中 而这些有毒物质会让你思维混乱 这就好像你尝试驾驶一辆油缸里混着糖粒的汽车 它们是不能正常工作的 事实上 少睡一点不止会让你在考试中发挥失常 长时间的睡眠不足 更会产生各种不好的副作用 比如头痛 抑郁症 心脏疾病 糖尿病 或 缩短寿命</code></pre><p><strong>在睡觉的时候 你的大脑会将你学习和思考过的想法以及概念进行整理 它会清除掉一些记忆中不太重要的部分 同时增强你需要或想要记住的区域的记忆</strong></p><p>在你睡着的时候，大脑会在脑中不断将你学习和思考过的想法以及概念进行整理，它会清楚一些记忆中不重要的部分，同时增强你需要或想要记住区域的记忆</p><pre><code>你首先必须通过做集中精力状态下的工作 在脑中搭建发散思维模型 如果你复习你正在学习的内容 在你打个小盹或晚上睡觉之前 你会有更大的机率梦见这些内容 若你更进一步 告诉自己你“想要”梦到这些内容的话 梦见它的机率会更大提升 梦见你的学习从本质上能够增强你对内容的理解能力 在一定程度上 它可以将你的记忆整合成更易被掌握的组块信息</code></pre><hr><h3 id="教授访谈"><a href="#教授访谈" class="headerlink" title="教授访谈"></a>教授访谈</h3><ul><li>学习完全陌生的事物时，通过实践对我来说比阅读文献来的有用</li><li>听不感兴趣的讲座的时候，通过给演讲者埋伏问题，由此引发出的讨论会更有趣</li><li>运动的时候跟容易进入发散思维</li><li>你无法头脑清晰地同时做两件事，两件事之间切换工作节奏也是需要时间的</li><li>我们需要充足的锻炼</li><li>处于一个富有创造力的环境中可以帮助自己学习创新、</li><li>聪明人并不一定会成功，人生中的成功多半来自于激情和努力 坚持到底 坚持研究、工作 不放弃 不要放弃</li></ul>]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> learning how to learn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
